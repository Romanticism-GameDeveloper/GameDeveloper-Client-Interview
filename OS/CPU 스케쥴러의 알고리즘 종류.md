# CPU 스케쥴러의 알고리즘 종류



## FCFS - First Come First Served

간단하게 먼저온 순으로 진행해 주는 것입니다. Non preemptive라서 현재 진행중인 프로세스를 종료할 수단이 없습니다.



## SJF - Shortest Job First

말 그대로 현재 시점에서 짧은 일을 먼저 처리하는 것입니다. 이 중에서도 Preemptive, Non preemptive가 존재합니다. Non preemptive의 경우에는 현재 실행하는 프로세스를 종료하지 않으며 Preemptive의 경우에는 현재 사용하는 프로세스보다 새 프로세스의 시간이 더 짧으면 교체하게 됩니다.



> **어떻게 프로세스의 시간을 알 수 있을까?**

프로세스를 실행하지 않고 시간을 정확히 알 수 없으니 '예측'을 하게 됩니다. 이 예측은 이전 프로세스의 '예상 수행시간'과 '실제 수행시간'을 기반으로 예측하게 됩니다.

- (N번째의 CPU 사용 예측치) = (적응속도) \* (N-1 프로세스의 실제 시간) + (1 - 적응속도) \* (N-1 프로세스 예측 시간)
  - 여기서 적응 속도는 0~1의 값을 가지고 0이 될수록 이전 예측에 좀 더 가중치를 주겠다는 이야기입니다.



## Priority - 우선순위 스케쥴링

각 프로세스에 우선순위를 부여하고 이 우선순위가 높을수록 먼저 CPU에 할당해 줍니다. 위 SJF의 경우에는 우선순위 스케쥴링의 일종으로 짧은 시간이라 예측된 프로세스에 우선도를 주는 형식입니다.

문제점은 우선순위가 낮은 프로세스는 우선순위가 높은 프로세스가 계속 들어온다면 계속 실행되지 못할 수도 있습니다. 이걸 기아(Starvation)문제라고 합니다. 이를 해결하기 위해서는 aging 기법을 활용해 시간이 흐를 때 우선순위를 높여줘야 합니다.



## RR - Round Robin

일전 시간을 정한 뒤 이 시간이 지나면 **프로세스 완료 여부와 관계 없이 종료하고 다른 프로세스로 교체**하는 것입니다.  만일 시간 단위가 q 라고 하고 N개의 프로세스가 있다고 하면 각 프로세스가 (N-1)q보다 기다리는 경우는 없습니다.



## SRTF(Shortest Remaining Time First)

특징
- 새로운 프로세스가 도착할 때마다 새로운 스케줄링이 이루어진다.
- 선점형 (Preemptive) 스케줄링
- 현재 수행중인 프로세스의 남은 burst time 보다 더 짧은 CPU burst time 을 가지는 새로운 프로세스가 도착하면 CPU 를 뺏긴다.

문제점
- starvation
- 새로운 프로세스가 도달할 때마다 스케줄링을 다시하기 때문에 CPU burst time(CPU 사용시간)을 측정할 수가 없다.
